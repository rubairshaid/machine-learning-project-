# -*- coding: utf-8 -*-
"""Project2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MvU2BwXP_cX-DPdHkSTN1U1GxHiBDp07

ruba irshaid , baraa iseed , sara edais
"""

#importing the needed library
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import cross_val_score
from matplotlib import pyplot as plt
from sklearn.neural_network import MLPRegressor
from sklearn.model_selection import cross_validate
from sklearn.model_selection import KFold
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import MinMaxScaler
from decimal import Decimal
import math

#reading data from the file and the needed columns 
data = pd.read_csv('/content/teram.csv', sep=";" , usecols=['Start date', 'Start station number'])
#check the data
print(data.keys())
print(data.shape)
print(data.loc[0])

#print the first and last 5 rows from the data frame 
print(data.head())
print (data.tail())

#split start date into date and time 
data[['date','time']]= data['Start date'].str.split(expand=True)
print (data)
#drop Start date column
data = data.drop('Start date',axis='columns')
print (data)
#check the data types of the columns  
data.dtypes

data['date'] = data.date.str.split('/').str[0].astype(int)
#drop time column "we take a day as a period"
data = data.drop('time',axis='columns')
print(data)

#grouping data to get the count of bikes needed in each station each day 
 #set the number of needed bikes in count column
 data = pd.DataFrame({'count' : data.groupby(['Start station number','date'] ).size()}).reset_index()
 #check the form of the new data frame 
 print (data)
 #check signle row 
 print(data.loc[1000])
 #describe the data 
 print(data.describe())

#knowing what is the maximum number of bikes needed 
data[data['count']==data['count'].max()]

#splitting the dataframe into features and target dataframes  
features = data[['Start station number', 'date']]
target = data[['count']]
#printing the features and the target 
print(features)
print(target)

#getting an overview of the data by plotting the relation between the features and the target 
plt.scatter(features['Start station number'] , target['count'])
plt.xlabel("Start station number")
plt.ylabel("count")
plt.show()
print("\n\n")
plt.scatter(features['date'] , target['count'])
plt.xlabel("date")
plt.ylabel("count")
plt.show()

#using linear regression  with 3 fold cross validation "planning 2"
LinearRegModel = LinearRegression()
cvLinear = KFold(n_splits=3, random_state=1, shuffle=True)
linearScore = cross_val_score(LinearRegModel, features, target, cv=cvLinear )
linearScore.mean()

#using random forest "planning 4"
RFregr = RandomForestRegressor()
cv = KFold(n_splits=10, random_state=1, shuffle=True)
RFscore = cross_val_score(RFregr, features,  target.values.ravel(), cv=cv)
print("The accurecy with Random forest is :")
print(RFscore.mean())
RFregr.fit(features , target)

#scale the features to minimize station number value 
scaler = MinMaxScaler()
scaler.fit(features)
features=scaler.transform(features)

#nular network "looping"
for i in range(10,150,40):
  clf = MLPRegressor(hidden_layer_sizes=(i,i,i),activation='relu',max_iter=25000)
  scores = cross_val_score(clf,  features, target.values.ravel(), cv=cv , scoring = "r2")
  print(scores)
  print("%0.2f accuracy with a hidden neurons = %0.2f" % (scores.mean(),i))

#training on nular network
nularReg = MLPRegressor(hidden_layer_sizes=(100,100,100),activation='logistic',max_iter=5000, solver = "lbfgs")
nularReg.fit(features,target.values.ravel())

print(nularReg.score(features,  target.values.ravel()))

#asking the user to enter the number if the station and day number 
inputStationNumber = int(input("Enter the station number \n"))
inputdate = int(input("Enter the date\n"))
prediction = RFregr.predict([[inputStationNumber, inputdate]])
print (prediction)
fraction = prediction % 1
if(fraction >0.5):
  prediction  = math.ceil(prediction)
else:
  prediction  = math.floor(prediction)
print ("The expected number of bikesto be located at station 31000 at "+str(inputStationNumber)+" time is " +  str(prediction))

#get the data of one station and display it "station # 31000"
oneStation = data.loc[data['Start station number'] == 31000]
print(oneStation)

#draw the data of one station in 3d 
import matplotlib.pyplot as plt

from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure(figsize=(10,10))

ax = fig.add_subplot(111, projection='3d')

ax.scatter(oneStation['date'],oneStation['count'])
plt.show()

#draw the relation between the date and the number of needed bikes in station 31000
print ("this is the plot of station # 31000 : ")
features2 = oneStation[[ 'date']]
target2 = oneStation[['count']]
plt.scatter(features2['date'] , target2['count'])
plt.xlabel("date")
plt.ylabel("count")
plt.show()